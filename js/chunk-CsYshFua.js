import{t,c as n,i as e,e as s,f as o,r as c,d as a,h as r,g as i,o as u,w as f,n as p,j as l,m as h,k as d,l as y}from"./chunk-DItFX9tw.js";
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let b;const v=t=>b=t,_=Symbol();function j(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}var g,m;function O(){const t=r(!0),n=t.run(()=>c({}));let e=[],s=[];const o=h({install(t){v(o),o._a=t,t.provide(_,o),t.config.globalProperties.$pinia=o,s.forEach(t=>e.push(t)),s=[]},use(t){return this._a?e.push(t):s.push(t),this},_p:e,_a:null,_e:t,_s:new Map,state:n});return o}(m=g||(g={})).direct="direct",m.patchObject="patch object",m.patchFunction="patch function";const $=()=>{};function S(t,n,e,s=$){t.push(n);const o=()=>{const e=t.indexOf(n);e>-1&&(t.splice(e,1),s())};return!e&&i()&&u(o),o}function P(t,...n){t.slice().forEach(t=>{t(...n)})}const w=t=>t(),E=Symbol(),k=Symbol();function x(t,n){t instanceof Map&&n instanceof Map?n.forEach((n,e)=>t.set(e,n)):t instanceof Set&&n instanceof Set&&n.forEach(t.add,t);for(const o in n){if(!n.hasOwnProperty(o))continue;const c=n[o],a=t[o];j(a)&&j(c)&&t.hasOwnProperty(o)&&!e(c)&&!s(c)?t[o]=x(a,c):t[o]=c}return t}const I=Symbol();function M(t){return!j(t)||!t.hasOwnProperty(I)}const{assign:A}=Object;function F(t){return!(!e(t)||!t.effect)}function C(n,o,i={},u,l,h){let d;const y=A({actions:{}},i),b={deep:!0};let _,j,m,O=[],I=[];const C=u.state.value[n];let J;function N(t){let e;_=j=!1,"function"==typeof t?(t(u.state.value[n]),e={type:g.patchFunction,storeId:n,events:m}):(x(u.state.value[n],t),e={type:g.patchObject,payload:t,storeId:n,events:m});const s=J=Symbol();p().then(()=>{J===s&&(_=!0)}),j=!0,P(O,e,u.state.value[n])}h||C||(u.state.value[n]={}),c({});const W=h?function(){const{state:t}=i,n=t?t():{};this.$patch(t=>{A(t,n)})}:$;const q=(t,e="")=>{if(E in t)return t[k]=e,t;const s=function(){v(u);const e=Array.from(arguments),o=[],c=[];let a;P(I,{args:e,name:s[k],store:B,after:function(t){o.push(t)},onError:function(t){c.push(t)}});try{a=t.apply(this&&this.$id===n?this:B,e)}catch(r){throw P(c,r),r}return a instanceof Promise?a.then(t=>(P(o,t),t)).catch(t=>(P(c,t),Promise.reject(t))):(P(o,a),a)};return s[E]=!0,s[k]=e,s},z={_p:u,$id:n,$onAction:S.bind(null,I),$patch:N,$reset:W,$subscribe(t,e={}){const s=S(O,t,e.detached,()=>o()),o=d.run(()=>f(()=>u.state.value[n],s=>{("sync"===e.flush?j:_)&&t({storeId:n,type:g.direct,events:m},s)},A({},b,e)));return s},$dispose:function(){d.stop(),O=[],I=[],u._s.delete(n)}},B=a(z);u._s.set(n,B);const D=(u._a&&u._a.runWithContext||w)(()=>u._e.run(()=>(d=r()).run(()=>o({action:q}))));for(const t in D){const o=D[t];if(e(o)&&!F(o)||s(o))h||(C&&M(o)&&(e(o)?o.value=C[t]:x(o,C[t])),u.state.value[n][t]=o);else if("function"==typeof o){const n=q(o,t);D[t]=n,y.actions[t]=o}}return A(B,D),A(t(B),D),Object.defineProperty(B,"$state",{get:()=>u.state.value[n],set:t=>{N(n=>{A(n,t)})}}),u._p.forEach(t=>{A(B,d.run(()=>t({store:B,app:u._a,pinia:u,options:y})))}),C&&h&&i.hydrate&&i.hydrate(B.$state,C),_=!0,j=!0,B}
/*! #__NO_SIDE_EFFECTS__ */function J(t,e,s){let o,c;const a="function"==typeof e;function r(t,s){const r=y();(t=t||(r?d(_,null):null))&&v(t),(t=b)._s.has(o)||(a?C(o,e,c,t):function(t,e,s){const{state:o,actions:c,getters:a}=e,r=s.state.value[t];let i;i=C(t,function(){r||(s.state.value[t]=o?o():{});const e=l(s.state.value[t]);return A(e,c,Object.keys(a||{}).reduce((e,o)=>(e[o]=h(n(()=>{v(s);const n=s._s.get(t);return a[o].call(n,n)})),e),{}))},e,s,0,!0)}(o,c,t));return t._s.get(o)}return"string"==typeof t?(o=t,c=a?s:e):(c=t,o=t.id),r.$id=o,r}function N(c){{const a=t(c),r={};for(const t in a){const i=a[t];i.effect?r[t]=n({get:()=>c[t],set(n){c[t]=n}}):(e(i)||s(i))&&(r[t]=o(c,t))}return r}}export{O as c,J as d,N as s};
